<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🎭 Meme Storage App</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
                sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            background-color: #f5f5f5;
        }

        .app {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .app-header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .app-header h1 {
            margin: 0 0 10px 0;
            font-size: 2.5rem;
            font-weight: 700;
        }

        .app-header p {
            margin: 0;
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .section {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            margin-bottom: 40px;
        }

        .section h2 {
            margin: 0 0 25px 0;
            color: #333;
            font-size: 1.5rem;
            font-weight: 600;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            font-weight: 600;
            color: #555;
            font-size: 0.95rem;
            margin-bottom: 8px;
        }

        .form-input {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.2s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .form-hint {
            color: #666;
            font-size: 0.85rem;
            margin-top: 4px;
        }

        .btn {
            padding: 14px 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .btn:disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }

        .search-container {
            position: relative;
            margin-bottom: 15px;
        }

        .search-input {
            width: 100%;
            padding: 12px 16px;
            padding-right: 45px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.2s ease;
        }

        .search-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .clear-btn {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            color: #999;
            padding: 4px;
            border-radius: 50%;
            transition: color 0.2s ease, background-color 0.2s ease;
        }

        .clear-btn:hover {
            color: #667eea;
            background-color: #f0f0f0;
        }

        .search-info {
            color: #666;
            font-size: 0.9rem;
        }

        .storage-info {
            color: #666;
            font-size: 0.85rem;
            margin-top: 5px;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 4px;
            border-left: 3px solid #667eea;
        }

        .storage-warning {
            border-left-color: #ffc107 !important;
            background: #fff8e1 !important;
        }

        .storage-danger {
            border-left-color: #dc3545 !important;
            background: #f8d7da !important;
            color: #721c24 !important;
        }

        .edit-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .edit-modal-content {
            background: white;
            padding: 30px;
            border-radius: 12px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .edit-modal h3 {
            margin: 0 0 20px 0;
            color: #333;
        }

        .edit-form {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .edit-btn {
            background: #17a2b8;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
            margin-right: 5px;
        }

        .edit-btn:hover {
            background: #138496;
        }

        .copy-btn {
            background: #6f42c1;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
            margin-right: 5px;
        }

        .copy-btn:hover {
            background: #5a36a4;
        }

        .meme-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 25px;
            margin-top: 20px;
        }

        .meme-card {
            background: #f8f9fa;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .meme-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
        }

        .meme-image-container {
            position: relative;
            height: 200px;
            overflow: hidden;
        }

        .meme-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.2s ease;
        }

        .meme-card:hover .meme-image {
            transform: scale(1.05);
        }

        .image-error {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            background: #f0f0f0;
            color: #666;
            text-align: center;
            padding: 20px;
        }

        .meme-info {
            padding: 20px;
        }

        .meme-title {
            margin: 0 0 15px 0;
            font-size: 1.1rem;
            font-weight: 600;
            color: #333;
        }

        .meme-keywords {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 15px;
        }

        .keyword-tag {
            background: #667eea;
            color: white;
            padding: 4px 8px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .meme-actions {
            display: flex;
            justify-content: flex-end;
            flex-wrap: wrap;
            gap: 5px;
        }

        .delete-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .delete-btn:hover {
            background: #c82333;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #666;
        }

        .empty-state h3 {
            margin: 0 0 10px 0;
            font-size: 1.5rem;
            color: #999;
        }

        .hidden {
            display: none;
        }

        .bulk-textarea {
            min-height: 150px;
            resize: vertical;
            font-family: monospace;
        }

        .bulk-progress {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px solid #e1e5e9;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e1e5e9;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .progress-text {
            text-align: center;
            color: #555;
            font-weight: 600;
        }

        .success-message {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
            padding: 12px;
            border-radius: 6px;
            margin-top: 10px;
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
            padding: 12px;
            border-radius: 6px;
            margin-top: 10px;
        }

        .upload-options {
            display: flex;
            gap: 20px;
            margin-bottom: 10px;
        }

        .upload-options input[type="radio"] {
            margin-right: 8px;
        }

        .radio-label {
            cursor: pointer;
            font-weight: 500;
            color: #555;
        }

        .radio-label:hover {
            color: #667eea;
        }

        .image-preview {
            margin-top: 10px;
        }

        .preview-image {
            max-width: 200px;
            max-height: 200px;
            border-radius: 8px;
            border: 2px solid #e1e5e9;
            object-fit: cover;
        }

        .bulk-image-preview {
            margin-top: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .bulk-preview-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #f8f9fa;
            border-radius: 8px;
            padding: 10px;
            border: 1px solid #e1e5e9;
        }

        .bulk-preview-image {
            width: 80px;
            height: 80px;
            object-fit: cover;
            border-radius: 4px;
            margin-bottom: 5px;
        }

        .bulk-preview-name {
            font-size: 0.75rem;
            color: #666;
            text-align: center;
            max-width: 80px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .file-size-info {
            color: #666;
            font-size: 0.8rem;
            margin-top: 5px;
        }

        .file-input {
            padding: 8px 12px !important;
            border: 2px dashed #667eea !important;
            background: #f8f9ff;
            cursor: pointer;
        }

        .file-input:hover {
            border-color: #5a67d8 !important;
            background: #f0f2ff;
        }

        .bulk-progress,
        .upload-progress {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px solid #e1e5e9;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e1e5e9;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .progress-text {
            text-align: center;
            color: #555;
            font-weight: 600;
        }

        @media (max-width: 768px) {
            .app {
                padding: 10px;
            }

            .app-header h1 {
                font-size: 2rem;
            }

            .section {
                padding: 20px;
            }

            .meme-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .meme-image-container {
                height: 250px;
            }

            .meme-info {
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="app">
        <header class="app-header">
            <h1>🎭 Meme Storage</h1>
            <p>Store and search your favorite memes!</p>
        </header>

        <main>
            <!-- Upload Section -->
            <section class="section">
                <h2>📤 Upload Memes</h2>
                <form id="uploadForm">
                    <div class="form-group">
                        <label for="title">Title (optional):</label>
                        <input type="text" id="title" class="form-input" placeholder="Enter a title for your meme">
                        <div class="form-hint">For multiple files, this will be used as a prefix with auto-numbering</div>
                    </div>
                    
                    <div class="form-group">
                        <label>Image Source:</label>
                        <div class="upload-options">
                            <input type="radio" id="uploadUrl" name="uploadMethod" value="url" checked>
                            <label for="uploadUrl" class="radio-label">🔗 Image URL</label>
                            
                            <input type="radio" id="uploadFile" name="uploadMethod" value="file">
                            <label for="uploadFile" class="radio-label">📁 Upload File</label>
                        </div>
                    </div>
                    
                    <div class="form-group" id="urlGroup">
                        <label for="imageUrl">Image URL:</label>
                        <input type="url" id="imageUrl" class="form-input" placeholder="https://example.com/meme.jpg">
                    </div>
                    
                    <div class="form-group hidden" id="fileGroup">
                        <label for="imageFiles">Select Image Files:</label>
                        <input type="file" id="imageFiles" class="form-input file-input" accept="image/*" multiple>
                        <div class="form-hint">Select one or multiple image files (JPG, PNG, GIF, WebP - up to 10MB each, automatically resized for optimal storage)</div>
                        <div id="imagePreview" class="image-preview"></div>
                    </div>
                    
                    <div class="form-group">
                        <label for="keywords">Keywords (comma-separated):</label>
                        <input type="text" id="keywords" class="form-input" placeholder="funny, cat, reaction, mood" required>
                        <div class="form-hint">Add keywords separated by commas to make your meme searchable</div>
                    </div>
                    
                    <button type="submit" class="btn" id="uploadBtn">🚀 Upload Memes</button>
                </form>
                
                <div id="uploadProgress" class="upload-progress hidden">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <div class="progress-text" id="progressText">Processing...</div>
                </div>
            </section>





            <!-- Search Section -->
            <section class="section">
                <h2>🔍 Search Memes</h2>
                <div class="search-container">
                    <input type="text" id="searchInput" class="search-input" placeholder="Search by keywords...">
                    <button id="clearSearch" class="clear-btn hidden">✕</button>
                </div>
                <div class="search-info" id="searchInfo">Total memes: 0</div>
                <div class="storage-info" id="storageInfo"></div>
            </section>

            <!-- Display Section -->
            <section class="section">
                <h2>🎨 Your Memes</h2>
                <div id="memeContainer">
                    <div class="empty-state">
                        <h3>🎭 No memes found</h3>
                        <p>Try uploading some memes or adjusting your search terms!</p>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <!-- Edit Modal -->
    <div id="editModal" class="edit-modal hidden">
        <div class="edit-modal-content">
            <h3>Edit Meme</h3>
            <form id="editForm" class="edit-form">
                <div class="form-group">
                    <label for="editTitle">Title:</label>
                    <input type="text" id="editTitle" class="form-input" required>
                </div>
                
                <div class="form-group">
                    <label for="editKeywords">Keywords (comma-separated):</label>
                    <input type="text" id="editKeywords" class="form-input" required>
                </div>
                
                <div class="modal-buttons">
                    <button type="button" class="btn btn-secondary" onclick="app.closeEditModal()">Cancel</button>
                    <button type="submit" class="btn">Save Changes</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        class MemeApp {
            constructor() {
                this.memes = JSON.parse(localStorage.getItem('memes') || '[]');
                this.filteredMemes = [...this.memes];
                this.searchTerm = '';
                this.init();
            }

            init() {
                this.bindEvents();
                this.render();
                this.currentEditingMeme = null;
            }

            bindEvents() {
                document.getElementById('uploadForm').addEventListener('submit', (e) => this.handleUpload(e));
                document.getElementById('editForm').addEventListener('submit', (e) => this.handleEdit(e));
                document.getElementById('searchInput').addEventListener('input', (e) => this.handleSearch(e));
                document.getElementById('clearSearch').addEventListener('click', () => this.clearSearch());
                
                // Radio button toggles
                document.getElementById('uploadUrl').addEventListener('change', () => this.toggleUploadMethod());
                document.getElementById('uploadFile').addEventListener('change', () => this.toggleUploadMethod());
                
                // File input previews
                document.getElementById('imageFiles').addEventListener('change', (e) => this.handleFilePreview(e));
                
                // Close modal on outside click
                document.getElementById('editModal').addEventListener('click', (e) => {
                    if (e.target.id === 'editModal') {
                        this.closeEditModal();
                    }
                });
                
                // Close share menus on outside click
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.share-dropdown')) {
                        this.closeAllShareMenus();
                    }
                });
            }

            async handleUpload(e) {
                e.preventDefault();
                
                const title = document.getElementById('title').value.trim() || 'Untitled Meme';
                const keywords = document.getElementById('keywords').value.trim();
                const uploadMethod = document.querySelector('input[name="uploadMethod"]:checked').value;

                if (!keywords) {
                    alert('Please provide keywords');
                    return;
                }

                // Check storage space before uploading
                if (!this.checkStorageSpace()) {
                    return;
                }

                let imageUrl = '';
                
                if (uploadMethod === 'url') {
                    imageUrl = document.getElementById('imageUrl').value.trim();
                    if (!imageUrl) {
                        alert('Please provide an image URL');
                        return;
                    }
                } else {
                    const fileInput = document.getElementById('imageFiles');
                    const files = Array.from(fileInput.files);
                    if (files.length === 0) {
                        alert('Please select image files');
                        return;
                    }
                    
                    // Handle multiple files
                    if (files.length > 1) {
                        return this.handleMultipleFiles(files, keywords);
                    }
                    
                    // Handle single file
                    const file = files[0];
                    if (!this.validateImageFile(file)) {
                        return;
                    }
                    
                    imageUrl = await this.fileToBase64(file);
                }

                const keywordArray = keywords.split(',').map(k => k.trim()).filter(k => k);
                
                const meme = {
                    id: Date.now(),
                    title,
                    imageUrl,
                    keywords: keywordArray,
                    createdAt: new Date().toISOString()
                };

                this.memes.push(meme);
                this.saveMemes();
                this.applySearch();
                this.render();
                
                // Reset form and previews
                document.getElementById('uploadForm').reset();
                document.getElementById('imagePreview').innerHTML = '';
            }

            async handleMultipleFiles(files, keywords) {
                const title = document.getElementById('title').value.trim() || 'Meme';
                const uploadBtn = document.getElementById('uploadBtn');
                const progressContainer = document.getElementById('uploadProgress');
                const progressFill = document.getElementById('progressFill');
                const progressText = document.getElementById('progressText');
                
                // Show progress
                progressContainer.classList.remove('hidden');
                uploadBtn.disabled = true;
                uploadBtn.textContent = 'Processing...';
                
                const keywordArray = keywords.split(',').map(k => k.trim()).filter(k => k);
                let successCount = 0;
                let errorCount = 0;
                
                // Process each file
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    const progress = ((i + 1) / files.length) * 100;
                    
                    progressFill.style.width = `${progress}%`;
                    progressText.textContent = `Processing ${i + 1} of ${files.length} files...`;
                    
                    try {
                        if (!this.validateImageFile(file)) {
                            errorCount++;
                            continue;
                        }
                        
                        const imageUrl = await this.fileToBase64(file);
                        const meme = {
                            id: Date.now() + i,
                            title: `${title} #${i + 1}`,
                            imageUrl: imageUrl,
                            keywords: [...keywordArray],
                            createdAt: new Date().toISOString()
                        };
                        
                        this.memes.push(meme);
                        successCount++;
                        
                        // Small delay to show progress
                        await new Promise(resolve => setTimeout(resolve, 50));
                        
                    } catch (error) {
                        errorCount++;
                        console.error(`Error processing ${file.name}:`, error);
                        
                        // If it's a timeout or storage error, show specific message
                        if (error.message.includes('timeout') || error.message.includes('storage')) {
                            progressText.innerHTML = `
                                <div class="error-message">
                                    Error: ${error.message}<br>
                                    Try using smaller images or deleting some existing memes.
                                </div>
                            `;
                            return; // Stop processing
                        }
                    }
                }
                
                // Save and update
                this.saveMemes();
                this.applySearch();
                this.render();
                
                // Show completion message
                progressText.innerHTML = `
                    <div class="success-message">
                        ✅ Successfully uploaded ${successCount} memes!
                        ${errorCount > 0 ? `<br>❌ ${errorCount} failed` : ''}
                    </div>
                `;
                
                // Reset form after delay
                setTimeout(() => {
                    document.getElementById('uploadForm').reset();
                    document.getElementById('imagePreview').innerHTML = '';
                    progressContainer.classList.add('hidden');
                    uploadBtn.disabled = false;
                    uploadBtn.textContent = '🚀 Upload Memes';
                    progressFill.style.width = '0%';
                }, 3000);
            }

            async handleBulkUpload(e) {
                e.preventDefault();
                
                const bulkKeywords = document.getElementById('bulkKeywords').value.trim();
                const bulkTitlePrefix = document.getElementById('bulkTitlePrefix').value.trim() || 'Meme';
                const bulkUploadMethod = document.querySelector('input[name="bulkUploadMethod"]:checked').value;

                if (!bulkKeywords) {
                    alert('Please provide keywords');
                    return;
                }

                let sources = [];
                
                if (bulkUploadMethod === 'url') {
                    const bulkUrls = document.getElementById('bulkUrls').value.trim();
                    if (!bulkUrls) {
                        alert('Please provide image URLs');
                        return;
                    }

                    // Parse URLs (split by newlines and filter out empty lines)
                    const urls = bulkUrls.split('\n')
                        .map(url => url.trim())
                        .filter(url => url.length > 0);

                    if (urls.length === 0) {
                        alert('Please provide at least one image URL');
                        return;
                    }

                    // Validate URLs
                    const urlPattern = /^https?:\/\/.+/;
                    const invalidUrls = urls.filter(url => !urlPattern.test(url));
                    if (invalidUrls.length > 0) {
                        alert(`Invalid URLs found:\n${invalidUrls.join('\n')}`);
                        return;
                    }
                    
                    sources = urls.map(url => ({ type: 'url', data: url }));
                } else {
                    const fileInput = document.getElementById('bulkFiles');
                    const files = Array.from(fileInput.files);
                    
                    if (files.length === 0) {
                        alert('Please select image files');
                        return;
                    }
                    
                    // Validate all files
                    for (const file of files) {
                        if (!this.validateImageFile(file)) {
                            return;
                        }
                    }
                    
                    sources = files.map(file => ({ type: 'file', data: file }));
                }

                // Show progress
                const progressContainer = document.getElementById('bulkProgress');
                const progressFill = document.getElementById('progressFill');
                const progressText = document.getElementById('progressText');
                const bulkUploadBtn = document.getElementById('bulkUploadBtn');
                
                progressContainer.classList.remove('hidden');
                bulkUploadBtn.disabled = true;
                bulkUploadBtn.textContent = 'Processing...';

                const keywordArray = bulkKeywords.split(',').map(k => k.trim()).filter(k => k);
                let successCount = 0;
                let errorCount = 0;
                const errors = [];

                // Process each source
                for (let i = 0; i < sources.length; i++) {
                    const source = sources[i];
                    const progress = ((i + 1) / sources.length) * 100;
                    
                    progressFill.style.width = `${progress}%`;
                    progressText.textContent = `Processing ${i + 1} of ${sources.length} memes...`;

                    try {
                        let imageUrl = '';
                        let sourceInfo = '';
                        
                        if (source.type === 'url') {
                            imageUrl = source.data;
                            sourceInfo = source.data;
                        } else {
                            imageUrl = await this.fileToBase64(source.data);
                            sourceInfo = source.data.name;
                        }

                        const meme = {
                            id: Date.now() + i, // Ensure unique IDs
                            title: `${bulkTitlePrefix} #${i + 1}`,
                            imageUrl: imageUrl,
                            keywords: [...keywordArray], // Copy array
                            createdAt: new Date().toISOString()
                        };

                        this.memes.push(meme);
                        successCount++;
                        
                        // Small delay to show progress
                        await new Promise(resolve => setTimeout(resolve, 100));
                        
                    } catch (error) {
                        errorCount++;
                        const sourceInfo = source.type === 'url' ? source.data : source.data.name;
                        errors.push(`${sourceInfo}: ${error.message}`);
                    }
                }

                // Save and update UI
                this.saveMemes();
                this.applySearch();
                this.render();

                // Show completion message
                progressText.innerHTML = `
                    <div class="success-message">
                        ✅ Successfully uploaded ${successCount} memes!
                        ${errorCount > 0 ? `<br>❌ ${errorCount} failed` : ''}
                    </div>
                `;

                if (errors.length > 0) {
                    console.error('Bulk upload errors:', errors);
                }

                // Reset form and hide progress after delay
                setTimeout(() => {
                    document.getElementById('bulkUploadForm').reset();
                    document.getElementById('bulkImagePreview').innerHTML = '';
                    progressContainer.classList.add('hidden');
                    bulkUploadBtn.disabled = false;
                    bulkUploadBtn.textContent = '📦 Upload All Memes';
                    progressFill.style.width = '0%';
                }, 3000);
            }

            handleSearch(e) {
                this.searchTerm = e.target.value;
                this.applySearch();
                this.render();
                
                // Show/hide clear button
                const clearBtn = document.getElementById('clearSearch');
                if (this.searchTerm) {
                    clearBtn.classList.remove('hidden');
                } else {
                    clearBtn.classList.add('hidden');
                }
            }

            clearSearch() {
                this.searchTerm = '';
                document.getElementById('searchInput').value = '';
                document.getElementById('clearSearch').classList.add('hidden');
                this.applySearch();
                this.render();
            }

            applySearch() {
                if (!this.searchTerm.trim()) {
                    this.filteredMemes = [...this.memes];
                } else {
                    this.filteredMemes = this.memes.filter(meme =>
                        meme.keywords.some(keyword =>
                            keyword.toLowerCase().includes(this.searchTerm.toLowerCase())
                        )
                    );
                }
            }

            deleteMeme(id) {
                if (confirm('Are you sure you want to delete this meme?')) {
                    this.memes = this.memes.filter(meme => meme.id !== id);
                    this.saveMemes();
                    this.applySearch();
                    this.render();
                }
            }

            saveMemes() {
                localStorage.setItem('memes', JSON.stringify(this.memes));
            }

            render() {
                this.renderSearchInfo();
                this.renderStorageInfo();
                this.renderMemes();
            }

            renderSearchInfo() {
                const searchInfo = document.getElementById('searchInfo');
                if (this.searchTerm) {
                    searchInfo.textContent = `Showing ${this.filteredMemes.length} of ${this.memes.length} memes for "${this.searchTerm}"`;
                } else {
                    searchInfo.textContent = `Total memes: ${this.memes.length}`;
                }
            }

            renderStorageInfo() {
                const storageInfo = document.getElementById('storageInfo');
                try {
                    const memesData = localStorage.getItem('memes') || '';
                    const used = new Blob([memesData]).size;
                    const maxStorage = 8 * 1024 * 1024; // 8MB
                    const usedMB = (used / 1024 / 1024).toFixed(2);
                    const maxMB = (maxStorage / 1024 / 1024).toFixed(0);
                    const percentage = ((used / maxStorage) * 100).toFixed(1);
                    
                    let className = 'storage-info';
                    let message = `Storage used: ${usedMB}MB / ${maxMB}MB (${percentage}%)`;
                    
                    if (used > maxStorage * 0.9) {
                        className += ' storage-danger';
                        message += ' - Nearly full! Delete some memes to free space.';
                    } else if (used > maxStorage * 0.7) {
                        className += ' storage-warning';
                        message += ' - Getting full. Consider deleting old memes.';
                    }
                    
                    storageInfo.className = className;
                    storageInfo.textContent = message;
                } catch (error) {
                    storageInfo.textContent = 'Storage info unavailable';
                }
            }

            renderMemes() {
                const container = document.getElementById('memeContainer');
                
                if (this.filteredMemes.length === 0) {
                    container.innerHTML = `
                        <div class="empty-state">
                            <h3>🎭 No memes found</h3>
                            <p>Try uploading some memes or adjusting your search terms!</p>
                        </div>
                    `;
                    return;
                }

                const memeGrid = document.createElement('div');
                memeGrid.className = 'meme-grid';

                this.filteredMemes.forEach(meme => {
                    const memeCard = document.createElement('div');
                    memeCard.className = 'meme-card';
                    memeCard.innerHTML = `
                        <div class="meme-image-container">
                            <img src="${meme.imageUrl}" alt="${meme.title}" class="meme-image" 
                                 onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                            <div class="image-error" style="display: none;">
                                <p>🚫 Failed to load image</p>
                                <small style="word-break: break-all;">${meme.imageUrl}</small>
                            </div>
                        </div>
                        <div class="meme-info">
                            <h3 class="meme-title">${meme.title}</h3>
                            <div class="meme-keywords">
                                ${meme.keywords.map(keyword => `<span class="keyword-tag">${keyword}</span>`).join('')}
                            </div>
                            <div class="meme-actions">
                                <button class="edit-btn" onclick="app.openEditModal(${meme.id})">✏️ Edit</button>
                                <button class="copy-btn" onclick="app.copyImage(${meme.id})">📋 Copy Image</button>
                                <button class="delete-btn" onclick="app.deleteMeme(${meme.id})">🗑️ Delete</button>
                            </div>
                        </div>
                    `;
                    memeGrid.appendChild(memeCard);
                });

                container.innerHTML = '';
                container.appendChild(memeGrid);
            }

            // Toggle between URL and file upload methods
            toggleUploadMethod() {
                const uploadMethod = document.querySelector('input[name="uploadMethod"]:checked').value;
                const urlGroup = document.getElementById('urlGroup');
                const fileGroup = document.getElementById('fileGroup');
                
                if (uploadMethod === 'url') {
                    urlGroup.classList.remove('hidden');
                    fileGroup.classList.add('hidden');
                    document.getElementById('imageUrl').required = true;
                    document.getElementById('imageFiles').required = false;
                } else {
                    urlGroup.classList.add('hidden');
                    fileGroup.classList.remove('hidden');
                    document.getElementById('imageUrl').required = false;
                    document.getElementById('imageFiles').required = true;
                }
            }

            toggleBulkUploadMethod() {
                const bulkUploadMethod = document.querySelector('input[name="bulkUploadMethod"]:checked').value;
                const bulkUrlGroup = document.getElementById('bulkUrlGroup');
                const bulkFileGroup = document.getElementById('bulkFileGroup');
                
                if (bulkUploadMethod === 'url') {
                    bulkUrlGroup.classList.remove('hidden');
                    bulkFileGroup.classList.add('hidden');
                    document.getElementById('bulkUrls').required = true;
                    document.getElementById('bulkFiles').required = false;
                } else {
                    bulkUrlGroup.classList.add('hidden');
                    bulkFileGroup.classList.remove('hidden');
                    document.getElementById('bulkUrls').required = false;
                    document.getElementById('bulkFiles').required = true;
                }
            }

            // Validate image file
            validateImageFile(file) {
                const maxSize = 10 * 1024 * 1024; // 10MB (will be automatically resized if needed)
                const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
                
                if (!allowedTypes.includes(file.type)) {
                    alert(`Invalid file type: ${file.type}. Please use JPG, PNG, GIF, or WebP.`);
                    return false;
                }
                
                if (file.size > maxSize) {
                    alert(`File too large: ${(file.size / 1024 / 1024).toFixed(2)}MB. Maximum size is 10MB.`);
                    return false;
                }
                
                return true;
            }

            // Check localStorage space
            checkStorageSpace() {
                try {
                    const used = new Blob([localStorage.getItem('memes') || '']).size;
                    const maxStorage = 8 * 1024 * 1024; // 8MB localStorage limit (increased)
                    
                    if (used > maxStorage * 0.85) { // Warn at 85%
                        alert('Warning: Storage is getting full. Consider deleting some memes to free up space.');
                        return true; // Still allow upload since images are auto-resized
                    }
                    
                    if (used > maxStorage) {
                        alert('Storage is full! Please delete some memes before uploading new ones.');
                        return false;
                    }
                    
                    return true;
                } catch (error) {
                    console.warn('Could not check storage space:', error);
                    return true; // Continue anyway
                }
            }

            // Resize image if it's too large
            async resizeImageIfNeeded(file) {
                return new Promise((resolve) => {
                    const maxDimension = 1200; // Max width or height
                    const targetQuality = 0.8; // 80% quality for JPEG
                    
                    const img = new Image();
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    img.onload = () => {
                        let { width, height } = img;
                        
                        // Calculate new dimensions
                        if (width > maxDimension || height > maxDimension) {
                            if (width > height) {
                                height = (height * maxDimension) / width;
                                width = maxDimension;
                            } else {
                                width = (width * maxDimension) / height;
                                height = maxDimension;
                            }
                        }
                        
                        // Set canvas size
                        canvas.width = width;
                        canvas.height = height;
                        
                        // Draw resized image
                        ctx.drawImage(img, 0, 0, width, height);
                        
                        // Convert to blob
                        canvas.toBlob((blob) => {
                            if (blob) {
                                resolve(blob);
                            } else {
                                resolve(file); // Fallback to original
                            }
                        }, file.type === 'image/png' ? 'image/png' : 'image/jpeg', targetQuality);
                    };
                    
                    img.onerror = () => {
                        resolve(file); // Fallback to original
                    };
                    
                    img.src = URL.createObjectURL(file);
                });
            }

            // Convert file to base64 with timeout and auto-resize
            async fileToBase64(file) {
                try {
                    // Resize image if needed
                    const processedFile = await this.resizeImageIfNeeded(file);
                    
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        
                        // Add timeout to prevent hanging
                        const timeout = setTimeout(() => {
                            reader.abort();
                            reject(new Error('File conversion timed out. Try a smaller image.'));
                        }, 30000); // 30 second timeout
                        
                        reader.onload = () => {
                            clearTimeout(timeout);
                            resolve(reader.result);
                        };
                        
                        reader.onerror = () => {
                            clearTimeout(timeout);
                            reject(new Error('Failed to read file. Please try again.'));
                        };
                        
                        reader.onabort = () => {
                            clearTimeout(timeout);
                            reject(new Error('File reading was aborted.'));
                        };
                        
                        try {
                            reader.readAsDataURL(processedFile);
                        } catch (error) {
                            clearTimeout(timeout);
                            reject(error);
                        }
                    });
                } catch (error) {
                    throw new Error('Failed to process image: ' + error.message);
                }
            }

            // Handle file preview (single or multiple)
            async handleFilePreview(e) {
                const files = Array.from(e.target.files);
                const previewContainer = document.getElementById('imagePreview');
                
                if (files.length === 0) {
                    previewContainer.innerHTML = '';
                    return;
                }
                
                // Handle single file
                if (files.length === 1) {
                    const file = files[0];
                    
                    if (!this.validateImageFile(file)) {
                        e.target.value = '';
                        previewContainer.innerHTML = '';
                        return;
                    }
                    
                    try {
                        const base64 = await this.fileToBase64(file);
                        previewContainer.innerHTML = `
                            <img src="${base64}" alt="Preview" class="preview-image">
                            <div class="file-size-info">
                                ${file.name} (${(file.size / 1024 / 1024).toFixed(2)}MB)
                            </div>
                        `;
                    } catch (error) {
                        previewContainer.innerHTML = '<div class="error-message">Error loading preview</div>';
                    }
                    return;
                }
                
                // Handle multiple files
                previewContainer.innerHTML = '<div>Loading previews...</div>';
                
                try {
                    const previews = await Promise.all(files.map(async (file, index) => {
                        if (!this.validateImageFile(file)) {
                            return null;
                        }
                        
                        const base64 = await this.fileToBase64(file);
                        return `
                            <div class="bulk-preview-item">
                                <img src="${base64}" alt="Preview ${index + 1}" class="bulk-preview-image">
                                <div class="bulk-preview-name">${file.name}</div>
                                <div class="file-size-info">${(file.size / 1024 / 1024).toFixed(2)}MB</div>
                            </div>
                        `;
                    }));
                    
                    const validPreviews = previews.filter(p => p !== null);
                    
                    if (validPreviews.length > 0) {
                        previewContainer.innerHTML = `
                            <div class="bulk-image-preview">
                                ${validPreviews.join('')}
                            </div>
                        `;
                    } else {
                        previewContainer.innerHTML = '<div class="error-message">No valid image files selected</div>';
                    }
                    
                } catch (error) {
                    previewContainer.innerHTML = '<div class="error-message">Error loading previews</div>';
                }
            }

            // Handle bulk file preview
            async handleBulkFilePreview(e) {
                const files = Array.from(e.target.files);
                const previewContainer = document.getElementById('bulkImagePreview');
                
                if (files.length === 0) {
                    previewContainer.innerHTML = '';
                    return;
                }
                
                previewContainer.innerHTML = '<div>Loading previews...</div>';
                
                try {
                    const previews = await Promise.all(files.map(async (file, index) => {
                        if (!this.validateImageFile(file)) {
                            return null;
                        }
                        
                        const base64 = await this.fileToBase64(file);
                        return `
                            <div class="bulk-preview-item">
                                <img src="${base64}" alt="Preview ${index + 1}" class="bulk-preview-image">
                                <div class="bulk-preview-name">${file.name}</div>
                                <div class="file-size-info">${(file.size / 1024 / 1024).toFixed(2)}MB</div>
                            </div>
                        `;
                    }));
                    
                    const validPreviews = previews.filter(p => p !== null);
                    previewContainer.innerHTML = validPreviews.join('');
                    
                } catch (error) {
                    previewContainer.innerHTML = '<div class="error-message">Error loading previews</div>';
                }
            }

            // Edit meme functions
            openEditModal(memeId) {
                const meme = this.memes.find(m => m.id === memeId);
                if (!meme) return;
                
                this.currentEditingMeme = meme;
                document.getElementById('editTitle').value = meme.title;
                document.getElementById('editKeywords').value = meme.keywords.join(', ');
                document.getElementById('editModal').classList.remove('hidden');
            }

            closeEditModal() {
                document.getElementById('editModal').classList.add('hidden');
                this.currentEditingMeme = null;
            }

            handleEdit(e) {
                e.preventDefault();
                
                if (!this.currentEditingMeme) return;
                
                const newTitle = document.getElementById('editTitle').value.trim();
                const newKeywords = document.getElementById('editKeywords').value.trim();
                
                if (!newTitle || !newKeywords) {
                    alert('Please fill in all fields');
                    return;
                }
                
                // Update the meme
                const memeIndex = this.memes.findIndex(m => m.id === this.currentEditingMeme.id);
                if (memeIndex !== -1) {
                    this.memes[memeIndex].title = newTitle;
                    this.memes[memeIndex].keywords = newKeywords.split(',').map(k => k.trim()).filter(k => k);
                    
                    this.saveMemes();
                    this.applySearch();
                    this.render();
                    this.closeEditModal();
                }
            }

            // Copy image function
            async copyImage(memeId) {
                const meme = this.memes.find(m => m.id === memeId);
                if (!meme) return;
                
                try {
                    // Convert base64 to blob
                    const response = await fetch(meme.imageUrl);
                    const blob = await response.blob();
                    
                    // Check if the browser supports the Clipboard API
                    if (navigator.clipboard && navigator.clipboard.write) {
                        await navigator.clipboard.write([
                            new ClipboardItem({
                                [blob.type]: blob
                            })
                        ]);
                        alert('Image copied to clipboard! You can now paste it anywhere.');
                    } else {
                        // Fallback for older browsers
                        alert('Clipboard API not supported in this browser. Try using Chrome, Firefox, or Safari.');
                    }
                } catch (error) {
                    console.error('Failed to copy image:', error);
                    alert('Failed to copy image. Please try again.');
                }
            }
        }

        // Initialize app when page loads
        let app;
        document.addEventListener('DOMContentLoaded', () => {
            app = new MemeApp();
        });
    </script>
</body>
</html> 